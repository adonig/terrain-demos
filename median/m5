sources:
    normals:
        type: Raster
        url: https://terrain-preview.mapzen.com/normal/{z}/{x}/{y}.png
        max_zoom: 15

lights:
    directional1:
        type: directional
        direction: [0.5,-0.7,-0.5]
        diffuse: [1, 1.000, 0.75]
        ambient: [0.2, 0.3, 0.3]

styles: 
    hillshade:
        base: raster
        lighting: false
        raster: normal
        shaders:
            blocks:
                global: |
                    // [0., 1.] -> [0, 255]
                    float quant(float x) {
                       x = clamp(x, 0., 1.);
                       return floor(x * 255.);
                    }

                    float pack(vec3 c) {
                       return (c.x + c.y + c.z) * (1. / 3.);
                    }

                    #define SWAP(a,b) { float t = sort[a]; sort[a] = sort[b]; sort[b] = t; }
                    // void bubble_sort(float sort[8], int num) {
                    //     for(int j = 0; j < num; ++j) {
                    //         for(int i= num-1; i >j; --i)
                    //         {
                    //            if(sort[i] < sort[i-1])
                    //            {
                    //                 SWAP(i, i-1);
                    //            }
                    //         }
                    //     }
                    // }
                normal: |
                    // median filter
                    // adapted from https://www.shadertoy.com/view/XstGW4

                    const int SORT_SIZE = 8;
                    const int SORT_SIZE_M1 = 7;

                    float sort[SORT_SIZE];
                    float medians[SORT_SIZE];

                    //const vec2 iResolution = vec2(512., 512.);

                    //vec2 ooRes = vec2(1.) / iResolution.xy;

                    for (int j=0; j<SORT_SIZE; j++)
                    {
                      for (int i=0; i<SORT_SIZE; i++)
                      {
                         //vec2 uv = (gl_FragCoord.xy + vec2(i,j)-vec2(SORT_SIZE/2)) * ooRes;
                         //float c = pack( texture2D(iChannel0,uv).rgb );
                         float c = pack ( normal );

                         sort[i] = c;
                      }
                      // bubble_sort(sort, SORT_SIZE);
                      
                      
                        for(int j = 0; j < SORT_SIZE; ++j) {
                            for(int i= SORT_SIZE_M1; i < SORT_SIZE; --i) {
                               if (i > j) continue;
                               if(sort[i] < sort[i-1]) {
                                    SWAP(i, i-1);
                               }
                            }
                        }
                      

                      float m = sort[(SORT_SIZE/2)];

                      medians[j] = m;
                    }

                    for (int i=0; i<SORT_SIZE; i++)
                    {
                      sort[i] = medians[i];
                    }
                    // bubble_sort(sort, SORT_SIZE);
                    
                        for(int j = 0; j < SORT_SIZE; ++j) {
                            for(int i= SORT_SIZE_M1; i < SORT_SIZE; --i) {
                               if (i > j) continue;
                               if(sort[i] < sort[i-1]) {
                                    SWAP(i, i-1);
                               }
                            }
                        }
                    normal = vec3(sort[SORT_SIZE/2]);

                color: |
                    // color.rgb = normal;
                    // color.rgb = 1. - normal;
                    // color.rgb = normal + 1.;
                    // color.rgb = normal / 2. + .5;
                    color.rgb = normal * 2. - .5;

layers:
    terrain:
        data: { source: normals, layer: _default }
        draw:
            hillshade:
                order: 0