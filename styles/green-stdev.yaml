sources:
    osm: 
        type: TopoJSON
        url: https://tile.mapzen.com/mapzen/vector/v1/all/{z}/{x}/{y}.topojson?api_key=mapzen-QF1osLn
        max_zoom: 16
    normals:
        type: Raster
        url: https://terrain-preview.mapzen.com/normal/{z}/{x}/{y}.png
        max_zoom: 15

lights:
    directional1:
        type: directional
        direction: [0.5,-0.7,-0.5]
        diffuse: [1, 1.000, 0.75]
        ambient: [0.2, 0.3, 0.3]

styles: 
    hillshade:
        base: raster
        # lighting: false
        raster: normal
        shaders:
            blocks:
                global: |
                    float normpdf(in float x, in float sigma) {
                        return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
                    }

                normal: |
                    //declare stuff
                    const int mSize = 4; // kernel width
                    const int kSize = (mSize-1)/2;
                    float kernel[mSize];
                    vec3 final = vec3(0.0);

                    //read out the texels
                    for (int i=-kSize; i <= kSize; ++i) {
                        for (int j=-kSize; j <= kSize; ++j) {
                            final += sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + vec2(float(i),float(j)))).rgb;
                        }
                    }

                    // find the mean of the samples values
                    final /= vec3((kSize*2+1)*(kSize*2+1));

                    vec3 squares = vec3(0.0);

                    for (int i=-kSize; i <= kSize; ++i) {
                        for (int j=-kSize; j <= kSize; ++j) {
                            squares += (sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + vec2(float(i),float(j)))).rgb - final)*(sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + vec2(float(i),float(j)))).rgb - final);
                        }
                    }

                    // find the mean of the squares
                    squares /= vec3((kSize*2+1)*(kSize*2+1));
                    
                    // then take the square root of the mean of the squares

                    // hmm, this doesn't look right.
                    // vec3 stdev = vec3(sqrt(squares));

                    // not sure about this, but it looks better
                    vec3 stdev = vec3(sqrt(squares.x));
                    stdev += vec3(sqrt(squares.y));
                    stdev += vec3(sqrt(squares.z));

                    // this version uses standard deviation to control the mix
                    vec3 slope = vec3(dot(vec3(0., 0., 1.), normal));

                    // don't know why * 8
                    normal = mix(final, normal, stdev * 8.);

layers:
    terrain:
        data: { source: normals, layer: _default }
        draw:
            hillshade:
                order: 0