sources:
    osm: 
        type: TopoJSON
        url: https://tile.mapzen.com/mapzen/vector/v1/all/{z}/{x}/{y}.topojson?api_key=mapzen-QF1osLn
        max_zoom: 16
    elevation:
        type: Raster
        url: https://terrain-preview.mapzen.com/terrarium/{z}/{x}/{y}.png
        max_zoom: 15

styles: 
    hillshade:
        base: raster
        lighting: false
        texcoords: true
        shaders: 
            blocks:
                global: |
                    float unpack(vec4 h) {
                        return (h.r * 1. + h.g / 256. + h.b / 65536.);
                    }
                    float normpdf(in float x, in float sigma) {
                        return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
                    }

                    void kernelop( out vec4 fragColor, in vec2 fragCoord ) {
                        return;
                    }

                    vec4 kernelop1( out vec4 fragColor, in vec2 fragCoord ) {
                        //declare stuff
                        const int mSize = 11;
                        const int kSize = (mSize-1)/2;
                        float kernel[mSize];
                        vec3 final_colour = vec3(0.0);

                        //create the 1-D kernel
                        float sigma = 7.0;
                        float Z = 0.0;
                        for (int j = 0; j <= kSize; ++j) {
                            kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);
                        }
                        
                        //get the normalization factor (as the gaussian has been clamped)
                        for (int j = 0; j < mSize; ++j) {
                            Z += kernel[j];
                        }

                        //read out the texels
                        for (int i=-kSize; i <= kSize; ++i) {
                            for (int j=-kSize; j <= kSize; ++j) {
                                final_colour += kernel[kSize+j]*kernel[kSize+i]*sampleRasterAtPixel(0, vec2(fragCoord + vec2(float(i),float(j))));
                            }
                        }
                        
                        return fragColor = vec4(final_colour/(Z*Z), 1.0);
                    }

                normal: |
                    // Normal from heightmap
                    // adapted from
                    // http://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map
                    // http://stackoverflow.com/questions/15178225/normal-map-from-height-map-artifact
                    float px = 1.;
                    vec3 off = vec3(-px, 0, px);

                    // Sample heightmap at center, left, right, above, below
                    float h11 = unpack(color);


                    float height = h11;
                    float h01 = unpack(sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + off.xy)));
                    float h21 = unpack(sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + off.zy)));
                    float h10 = unpack(sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + off.yx)));
                    float h12 = unpack(sampleRasterAtPixel(0, vec2(currentRasterPixel(0) + off.yz)));



                    // center/right + center/up kernel (sharper)
                    // vec3 va = normalize(vec3(off.z/4./rasterPixelSize(0).x, 0.0, h21 - h11));
                    // vec3 vb = normalize(vec3(0.0, off.z/4./rasterPixelSize(0).x, h12 - h11));
                    // left/right + up/down kernel (softer)
                    vec3 va = normalize(vec3(off.xy/-2./rasterPixelSize(0),h21-h01));
                    vec3 vb = normalize(vec3(off.yx/-2./rasterPixelSize(0),h12-h10));

                    normal = normalize(cross(va, vb));

                color: |
                    color.rgb = normal / 2. + .5;

layers:
    terrain:
        data: { source: elevation, layer: _default }
        draw:
            hillshade:
                order: 0
